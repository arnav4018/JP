const mongoose = require('mongoose');

const notificationSchema = new mongoose.Schema({
    // Recipient information
    recipient: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: [true, 'Recipient is required'],
        index: true
    },
    
    // Notification type and category
    type: {
        type: String,
        enum: [
            'application_status',
            'new_job_match',
            'interview_scheduled',
            'message_received',
            'payment_success',
            'payment_failed',
            'profile_incomplete',
            'resume_viewed',
            'job_expiring',
            'referral_bonus',
            'system_update',
            'security_alert',
            'welcome',
            'email_verification',
            'password_reset'
        ],
        required: [true, 'Notification type is required'],
        index: true
    },
    
    category: {
        type: String,
        enum: ['info', 'success', 'warning', 'error', 'alert'],
        default: 'info'
    },
    
    // Notification content
    title: {
        type: String,
        required: [true, 'Notification title is required'],
        maxlength: [200, 'Title cannot exceed 200 characters'],
        trim: true
    },
    
    message: {
        type: String,
        required: [true, 'Notification message is required'],
        maxlength: [1000, 'Message cannot exceed 1000 characters'],
        trim: true
    },
    
    // Rich content support
    data: {
        type: mongoose.Schema.Types.Mixed,
        default: {}
    },
    
    // Related entities
    relatedJob: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Job'
    },
    
    relatedApplication: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Application'
    },
    
    relatedUser: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    
    relatedPayment: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Payment'
    },
    
    // Delivery channels and status
    channels: [{
        type: {
            type: String,
            enum: ['push', 'email', 'sms', 'in_app'],
            required: true
        },
        status: {
            type: String,
            enum: ['pending', 'sent', 'delivered', 'failed', 'bounced'],
            default: 'pending'
        },
        sentAt: Date,
        deliveredAt: Date,
        failureReason: String,
        metadata: {
            messageId: String,
            provider: String,
            cost: Number
        }
    }],
    
    // User interaction
    status: {
        type: String,
        enum: ['unread', 'read', 'archived', 'dismissed'],
        default: 'unread',
        index: true
    },
    
    readAt: Date,
    
    priority: {
        type: String,
        enum: ['low', 'normal', 'high', 'urgent'],
        default: 'normal',
        index: true
    },
    
    // Scheduling
    scheduledFor: {
        type: Date,
        index: true
    },
    
    expiresAt: {
        type: Date,
        index: true
    },
    
    // Action buttons/links
    actions: [{
        label: {
            type: String,
            required: true,
            maxlength: 50
        },
        url: String,
        action: String, // For in-app actions
        style: {
            type: String,
            enum: ['primary', 'secondary', 'success', 'warning', 'danger'],
            default: 'primary'
        }
    }],
    
    // Grouping and batching
    groupId: {
        type: String,
        index: true
    },
    
    batchId: {
        type: String,
        index: true
    },
    
    // Template information
    template: {
        name: String,
        version: String,
        variables: mongoose.Schema.Types.Mixed
    },
    
    // Personalization
    personalization: {
        language: {
            type: String,
            default: 'en'
        },
        timezone: String,
        customFields: mongoose.Schema.Types.Mixed
    },
    
    // Analytics
    analytics: {
        opened: {
            type: Boolean,
            default: false
        },
        openedAt: Date,
        clickedLinks: [{
            url: String,
            clickedAt: {
                type: Date,
                default: Date.now
            }
        }],
        deviceInfo: {
            userAgent: String,
            platform: String,
            browser: String
        }
    },
    
    // System fields
    isAutoGenerated: {
        type: Boolean,
        default: true
    },
    
    createdBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    
    isDeleted: {
        type: Boolean,
        default: false
    },
    
    deletedAt: Date
}, {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

// Virtual for time since created
notificationSchema.virtual('timeAgo').get(function() {
    const now = new Date();
    const diffMs = now - this.createdAt;
    const diffMins = Math.floor(diffMs / 60000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins} minutes ago`;
    
    const diffHours = Math.floor(diffMins / 60);
    if (diffHours < 24) return `${diffHours} hours ago`;
    
    const diffDays = Math.floor(diffHours / 24);
    if (diffDays < 30) return `${diffDays} days ago`;
    
    return this.createdAt.toLocaleDateString();
});

// Virtual for checking if notification is expired
notificationSchema.virtual('isExpired').get(function() {
    return this.expiresAt && this.expiresAt < new Date();
});

// Virtual for overall delivery status
notificationSchema.virtual('deliveryStatus').get(function() {
    if (this.channels.length === 0) return 'not_sent';
    
    const statuses = this.channels.map(channel => channel.status);
    
    if (statuses.every(status => status === 'delivered')) return 'delivered';
    if (statuses.some(status => status === 'delivered')) return 'partially_delivered';
    if (statuses.every(status => status === 'failed' || status === 'bounced')) return 'failed';
    if (statuses.some(status => status === 'sent')) return 'sent';
    
    return 'pending';
});

// Indexes for performance
notificationSchema.index({ recipient: 1, status: 1, createdAt: -1 });
notificationSchema.index({ type: 1, createdAt: -1 });
notificationSchema.index({ scheduledFor: 1, status: 1 });
notificationSchema.index({ expiresAt: 1 });
notificationSchema.index({ groupId: 1, createdAt: -1 });
notificationSchema.index({ batchId: 1 });

// Compound indexes
notificationSchema.index({
    recipient: 1,
    status: 1,
    priority: 1,
    createdAt: -1
});

notificationSchema.index({
    type: 1,
    'channels.type': 1,
    'channels.status': 1
});

// Pre-save middleware
notificationSchema.pre('save', function(next) {
    // Set scheduled for current time if not provided
    if (!this.scheduledFor) {
        this.scheduledFor = new Date();
    }
    
    // Set default expiry (30 days from creation)
    if (!this.expiresAt) {
        this.expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
    }
    
    next();
});

// Instance methods
notificationSchema.methods.markAsRead = function() {
    this.status = 'read';
    this.readAt = new Date();
    return this.save();
};

notificationSchema.methods.archive = function() {
    this.status = 'archived';
    return this.save();
};

notificationSchema.methods.dismiss = function() {
    this.status = 'dismissed';
    return this.save();
};

notificationSchema.methods.markChannelDelivered = function(channelType, deliveryData = {}) {
    const channel = this.channels.find(ch => ch.type === channelType);
    if (channel) {
        channel.status = 'delivered';
        channel.deliveredAt = new Date();
        
        if (deliveryData.messageId) channel.metadata.messageId = deliveryData.messageId;
        if (deliveryData.provider) channel.metadata.provider = deliveryData.provider;
        if (deliveryData.cost) channel.metadata.cost = deliveryData.cost;
    }
    return this.save();
};

notificationSchema.methods.markChannelFailed = function(channelType, reason) {
    const channel = this.channels.find(ch => ch.type === channelType);
    if (channel) {
        channel.status = 'failed';
        channel.failureReason = reason;
    }
    return this.save();
};

notificationSchema.methods.trackClick = function(url, deviceInfo = {}) {
    this.analytics.clickedLinks.push({
        url,
        clickedAt: new Date()
    });
    
    if (!this.analytics.opened) {
        this.analytics.opened = true;
        this.analytics.openedAt = new Date();
    }
    
    if (deviceInfo) {
        this.analytics.deviceInfo = deviceInfo;
    }
    
    return this.save();
};

notificationSchema.methods.trackOpen = function(deviceInfo = {}) {
    if (!this.analytics.opened) {
        this.analytics.opened = true;
        this.analytics.openedAt = new Date();
        
        if (deviceInfo) {
            this.analytics.deviceInfo = deviceInfo;
        }
        
        return this.save();
    }
    return Promise.resolve(this);
};

// Static methods
notificationSchema.statics.createNotification = async function(notificationData) {
    const {
        recipientId,
        type,
        title,
        message,
        category = 'info',
        priority = 'normal',
        channels = ['in_app'],
        data = {},
        actions = [],
        relatedEntities = {},
        template = null,
        scheduledFor = null,
        expiresAt = null
    } = notificationData;

    const notification = new this({
        recipient: recipientId,
        type,
        title,
        message,
        category,
        priority,
        data,
        actions,
        scheduledFor,
        expiresAt,
        template,
        channels: channels.map(channelType => ({
            type: channelType,
            status: 'pending'
        })),
        ...relatedEntities
    });

    return await notification.save();
};

notificationSchema.statics.getNotificationsForUser = async function(userId, options = {}) {
    const {
        page = 1,
        limit = 20,
        status = null,
        type = null,
        priority = null,
        unreadOnly = false
    } = options;

    const query = {
        recipient: userId,
        isDeleted: false,
        $or: [
            { expiresAt: { $gt: new Date() } },
            { expiresAt: null }
        ]
    };

    if (status) query.status = status;
    if (type) query.type = type;
    if (priority) query.priority = priority;
    if (unreadOnly) query.status = 'unread';

    const notifications = await this.find(query)
        .populate('relatedJob', 'title company')
        .populate('relatedApplication', 'status')
        .populate('relatedUser', 'firstName lastName avatar')
        .populate('createdBy', 'firstName lastName')
        .sort({ priority: -1, createdAt: -1 })
        .skip((page - 1) * limit)
        .limit(limit);

    const total = await this.countDocuments(query);

    return {
        notifications,
        pagination: {
            page: parseInt(page),
            limit: parseInt(limit),
            total,
            pages: Math.ceil(total / limit)
        }
    };
};

notificationSchema.statics.getUnreadCount = async function(userId) {
    return await this.countDocuments({
        recipient: userId,
        status: 'unread',
        isDeleted: false,
        $or: [
            { expiresAt: { $gt: new Date() } },
            { expiresAt: null }
        ]
    });
};

notificationSchema.statics.markAllAsRead = async function(userId, types = []) {
    const query = {
        recipient: userId,
        status: 'unread',
        isDeleted: false
    };

    if (types.length > 0) {
        query.type = { $in: types };
    }

    const result = await this.updateMany(query, {
        $set: {
            status: 'read',
            readAt: new Date()
        }
    });

    return result.modifiedCount;
};

notificationSchema.statics.bulkCreate = async function(notifications) {
    return await this.insertMany(notifications, { ordered: false });
};

notificationSchema.statics.getPendingNotifications = async function(channelType = null) {
    const query = {
        scheduledFor: { $lte: new Date() },
        isDeleted: false,
        $or: [
            { expiresAt: { $gt: new Date() } },
            { expiresAt: null }
        ]
    };

    if (channelType) {
        query['channels.type'] = channelType;
        query['channels.status'] = 'pending';
    }

    return await this.find(query)
        .populate('recipient', 'firstName lastName email phone')
        .populate('relatedJob', 'title company')
        .populate('relatedApplication', 'status')
        .sort({ priority: -1, scheduledFor: 1 });
};

notificationSchema.statics.cleanupExpiredNotifications = async function() {
    const result = await this.updateMany(
        {
            expiresAt: { $lt: new Date() },
            isDeleted: false
        },
        {
            $set: {
                isDeleted: true,
                deletedAt: new Date()
            }
        }
    );

    return result.modifiedCount;
};

notificationSchema.statics.getAnalytics = async function(startDate, endDate, groupBy = 'day') {
    const pipeline = [
        {
            $match: {
                createdAt: {
                    $gte: new Date(startDate),
                    $lte: new Date(endDate)
                },
                isDeleted: false
            }
        },
        {
            $group: {
                _id: {
                    type: '$type',
                    date: {
                        $dateToString: {
                            format: groupBy === 'day' ? '%Y-%m-%d' : '%Y-%m',
                            date: '$createdAt'
                        }
                    }
                },
                count: { $sum: 1 },
                delivered: {
                    $sum: {
                        $cond: [
                            { $eq: ['$deliveryStatus', 'delivered'] },
                            1,
                            0
                        ]
                    }
                },
                opened: {
                    $sum: {
                        $cond: ['$analytics.opened', 1, 0]
                    }
                },
                clicked: {
                    $sum: {
                        $cond: [
                            { $gt: [{ $size: '$analytics.clickedLinks' }, 0] },
                            1,
                            0
                        ]
                    }
                }
            }
        },
        {
            $sort: { '_id.date': 1, '_id.type': 1 }
        }
    ];

    return await this.aggregate(pipeline);
};

module.exports = mongoose.model('Notification', notificationSchema);